<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB è¿ç§»è°ƒè¯•å·¥å…·</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        .section h3 {
            margin-top: 0;
            color: #333;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button.danger {
            background: #dc3545;
        }
        button.danger:hover {
            background: #c82333;
        }
        button.success {
            background: #28a745;
        }
        button.success:hover {
            background: #218838;
        }
        .result {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>IndexedDB è¿ç§»è°ƒè¯•å·¥å…·</h1>
        <p>ç”¨äºè¯Šæ–­å’Œä¿®å¤ Prompt Ray çš„å­˜å‚¨è¿ç§»é—®é¢˜</p>

        <div class="section">
            <h3>1. æ£€æŸ¥å­˜å‚¨çŠ¶æ€</h3>
            <button onclick="checkStorageStatus()">æ£€æŸ¥å­˜å‚¨çŠ¶æ€</button>
            <div id="storage-status" class="result"></div>
        </div>

        <div class="section">
            <h3>2. æ£€æŸ¥è¿ç§»çŠ¶æ€</h3>
            <button onclick="checkMigrationStatus()">æ£€æŸ¥è¿ç§»çŠ¶æ€</button>
            <div id="migration-status" class="result"></div>
        </div>

        <div class="section">
            <h3>3. å¼ºåˆ¶æ‰§è¡Œè¿ç§»</h3>
            <button onclick="forceMigration()" class="success">æ‰§è¡Œå®Œæ•´è¿ç§»</button>
            <button onclick="clearMigrationStatus()" class="danger">æ¸…é™¤è¿ç§»çŠ¶æ€</button>
            <div id="migration-result" class="result"></div>
        </div>

        <div class="section">
            <h3>4. æ£€æŸ¥ IndexedDB å†…å®¹</h3>
            <button onclick="checkIndexedDB()">æ£€æŸ¥ IndexedDB</button>
            <button onclick="clearIndexedDB()" class="danger">æ¸…ç©º IndexedDB</button>
            <div id="idb-content" class="result"></div>
        </div>

        <div class="section">
            <h3>5. å®Œæ•´è¯Šæ–­</h3>
            <button onclick="fullDiagnostic()">è¿è¡Œå®Œæ•´è¯Šæ–­</button>
            <div id="diagnostic-result" class="result"></div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿ storageService çš„æ ¸å¿ƒåŠŸèƒ½
        const STORAGE_KEY = 'prompts_data_v2';
        const MIGRATION_STATUS_KEY = 'migration_status_v1';

        async function checkStorageStatus() {
            const result = document.getElementById('storage-status');
            result.innerHTML = 'æ£€æŸ¥ä¸­...';

            try {
                const localStorageData = localStorage.getItem(STORAGE_KEY);
                const categories = localStorage.getItem('prompts_categories_v1');
                const theme = localStorage.getItem('prompts_theme_v1');
                const filters = localStorage.getItem('prompts_filters_v1');

                let output = 'ğŸ“¦ LocalStorage çŠ¶æ€:\n';
                output += `æç¤ºè¯æ•°æ®: ${localStorageData ? `${JSON.parse(localStorageData).length} æ¡` : 'ç©º'}\n`;
                output += `åˆ†ç±»æ•°æ®: ${categories || 'ç©º'}\n`;
                output += `ä¸»é¢˜è®¾ç½®: ${theme || 'ç©º'}\n`;
                output += `ç­›é€‰å™¨çŠ¶æ€: ${filters || 'ç©º'}\n`;

                result.innerHTML = output;
            } catch (error) {
                result.innerHTML = `âŒ æ£€æŸ¥å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        async function checkMigrationStatus() {
            const result = document.getElementById('migration-status');
            result.innerHTML = 'æ£€æŸ¥ä¸­...';

            try {
                const status = localStorage.getItem(MIGRATION_STATUS_KEY);
                if (status) {
                    const parsed = JSON.parse(status);
                    result.innerHTML = `ğŸ“Š è¿ç§»çŠ¶æ€: ${JSON.stringify(parsed, null, 2)}`;
                } else {
                    result.innerHTML = 'ğŸ“Š è¿ç§»çŠ¶æ€: æœªæ‰¾åˆ° (å°†è‡ªåŠ¨åˆ›å»º)';
                }
            } catch (error) {
                result.innerHTML = `âŒ æ£€æŸ¥å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        async function forceMigration() {
            const result = document.getElementById('migration-result');
            result.innerHTML = 'è¿ç§»ä¸­...';

            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®éœ€è¦è¿ç§»
                const localStorageData = localStorage.getItem(STORAGE_KEY);
                if (!localStorageData) {
                    result.innerHTML = 'âŒ LocalStorage ä¸­æ²¡æœ‰æ•°æ®ï¼Œæ— éœ€è¿ç§»';
                    result.className = 'result error';
                    return;
                }

                const prompts = JSON.parse(localStorageData);
                console.log(`æ‰¾åˆ° ${prompts.length} æ¡æç¤ºè¯æ•°æ®`);

                // æ‰“å¼€ IndexedDB
                const db = await openIndexedDB();
                console.log('IndexedDB å·²æ‰“å¼€');

                // æ¸…ç©ºç°æœ‰æ•°æ®
                await clearAllIDBData(db);

                // è¿ç§»æç¤ºè¯æ•°æ®
                await migratePrompts(db, prompts);

                // è¿ç§»å…¶ä»–æ•°æ®
                await migrateCategories(db);
                await migrateTheme(db);
                await migrateFilters(db);

                // æ›´æ–°è¿ç§»çŠ¶æ€
                const migrationStatus = {
                    isCompleted: true,
                    version: '2.0.0',
                    migratedItems: prompts.length,
                    errors: [],
                    lastMigrationAt: Date.now()
                };

                localStorage.setItem(MIGRATION_STATUS_KEY, JSON.stringify(migrationStatus));

                result.innerHTML = `âœ… è¿ç§»æˆåŠŸ!\nè¿ç§»äº† ${prompts.length} æ¡æ•°æ®\næ—¶é—´: ${new Date().toLocaleString()}`;
                result.className = 'result success';

                console.log('è¿ç§»å®Œæˆ:', migrationStatus);

            } catch (error) {
                result.innerHTML = `âŒ è¿ç§»å¤±è´¥: ${error.message}`;
                result.className = 'result error';
                console.error('è¿ç§»é”™è¯¯:', error);
            }
        }

        async function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PromptRayDB', 2);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // åˆ›å»ºå¯¹è±¡å­˜å‚¨
                    if (!db.objectStoreNames.contains('prompts')) {
                        const promptsStore = db.createObjectStore('prompts', { keyPath: 'id' });
                        promptsStore.createIndex('category', 'category', { unique: false });
                        promptsStore.createIndex('isFavorite', 'isFavorite', { unique: false });
                        promptsStore.createIndex('createdAt', 'createdAt', { unique: false });
                        promptsStore.createIndex('status', 'status', { unique: false });
                        promptsStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
                    }

                    if (!db.objectStoreNames.contains('categories')) {
                        db.createObjectStore('categories', { keyPath: 'id' });
                    }

                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                    }
                };
            });
        }

        async function clearAllIDBData(db) {
            const stores = ['prompts', 'categories', 'settings'];
            for (const storeName of stores) {
                if (db.objectStoreNames.contains(storeName)) {
                    await new Promise((resolve, reject) => {
                        const transaction = db.transaction(storeName, 'readwrite');
                        const request = transaction.objectStore(storeName).clear();
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }
            }
        }

        async function migratePrompts(db, prompts) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('prompts', 'readwrite');
                const store = transaction.objectStore('prompts');

                let completed = 0;
                const total = prompts.length;

                if (total === 0) {
                    resolve();
                    return;
                }

                prompts.forEach(prompt => {
                    const request = store.add(prompt);
                    request.onsuccess = () => {
                        completed++;
                        if (completed === total) resolve();
                    };
                    request.onerror = () => {
                        console.error('Failed to migrate prompt:', prompt.id);
                        completed++;
                        if (completed === total) resolve(); // Continue even on error
                    };
                });
            });
        }

        async function migrateCategories(db) {
            const categories = localStorage.getItem('prompts_categories_v1');
            if (!categories) return;

            const categoryList = JSON.parse(categories);
            if (!Array.isArray(categoryList)) return;

            const transaction = db.transaction('categories', 'readwrite');
            const store = transaction.objectStore('categories');

            for (let i = 0; i < categoryList.length; i++) {
                const category = {
                    id: `category_${categoryList[i]}`,
                    name: categoryList[i],
                    createdAt: Date.now()
                };

                await new Promise((resolve, reject) => {
                    const request = store.add(category);
                    request.onsuccess = () => resolve();
                    request.onerror = () => resolve(); // Continue on error
                });
            }
        }

        async function migrateTheme(db) {
            const theme = localStorage.getItem('prompts_theme_v1');
            if (!theme) return;

            const transaction = db.transaction('settings', 'readwrite');
            const store = transaction.objectStore('settings');

            await new Promise((resolve, reject) => {
                const request = store.put({ key: 'user_theme', value: theme, updatedAt: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function migrateFilters(db) {
            const filters = localStorage.getItem('prompts_filters_v1');
            if (!filters) return;

            const transaction = db.transaction('settings', 'readwrite');
            const store = transaction.objectStore('settings');

            await new Promise((resolve, reject) => {
                const request = store.put({ key: 'filter_state', value: JSON.parse(filters), updatedAt: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => resolve();
            });
        }

        async function clearMigrationStatus() {
            localStorage.removeItem(MIGRATION_STATUS_KEY);
            document.getElementById('migration-status').innerHTML = 'âœ… è¿ç§»çŠ¶æ€å·²æ¸…é™¤';
        }

        async function checkIndexedDB() {
            const result = document.getElementById('idb-content');
            result.innerHTML = 'æ£€æŸ¥ä¸­...';

            try {
                const db = await openIndexedDB();

                let output = 'ğŸ” IndexedDB å†…å®¹:\n\n';

                // æ£€æŸ¥ prompts
                const prompts = await getAllFromStore(db, 'prompts');
                output += `æç¤ºè¯æ•°æ®: ${prompts.length} æ¡\n`;

                // æ£€æŸ¥ categories
                const categories = await getAllFromStore(db, 'categories');
                output += `åˆ†ç±»æ•°æ®: ${categories.length} æ¡\n`;

                // æ£€æŸ¥ settings
                const settings = await getAllFromStore(db, 'settings');
                output += `è®¾ç½®æ•°æ®: ${settings.length} æ¡\n`;

                if (prompts.length > 0) {
                    output += '\nğŸ“ ç¤ºä¾‹æç¤ºè¯:\n';
                    const sample = prompts.slice(0, 3);
                    sample.forEach(p => {
                        output += `- ${p.title} (${p.category})\n`;
                    });
                }

                result.innerHTML = output;
                db.close();

            } catch (error) {
                result.innerHTML = `âŒ æ£€æŸ¥å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        async function getAllFromStore(db, storeName) {
            return new Promise((resolve, reject) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    resolve([]);
                    return;
                }

                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        async function clearIndexedDB() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©º IndexedDB ä¸­çš„æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯é€†ï¼')) {
                return;
            }

            try {
                const db = await openIndexedDB();
                await clearAllIDBData(db);
                db.close();

                document.getElementById('idb-content').innerHTML = 'âœ… IndexedDB å·²æ¸…ç©º';
            } catch (error) {
                document.getElementById('idb-content').innerHTML = `âŒ æ¸…ç©ºå¤±è´¥: ${error.message}`;
                document.getElementById('idb-content').className = 'result error';
            }
        }

        async function fullDiagnostic() {
            const result = document.getElementById('diagnostic-result');
            result.innerHTML = 'è¿è¡Œå®Œæ•´è¯Šæ–­...';

            try {
                let output = 'ğŸ”¬ å®Œæ•´è¯Šæ–­æŠ¥å‘Š\n';
                output += '=' .repeat(50) + '\n\n';

                // æ£€æŸ¥ localStorage
                const localData = localStorage.getItem(STORAGE_KEY);
                output += `ğŸ“¦ LocalStorage:\n`;
                output += `  æç¤ºè¯æ•°æ®: ${localData ? `${JSON.parse(localData).length} æ¡` : 'ç©º'}\n`;
                output += `  åˆ†ç±»æ•°æ®: ${localStorage.getItem('prompts_categories_v1') || 'ç©º'}\n`;
                output += `  ä¸»é¢˜è®¾ç½®: ${localStorage.getItem('prompts_theme_v1') || 'ç©º'}\n\n`;

                // æ£€æŸ¥è¿ç§»çŠ¶æ€
                const migrationStatus = localStorage.getItem(MIGRATION_STATUS_KEY);
                output += `ğŸ“Š è¿ç§»çŠ¶æ€: ${migrationStatus ? JSON.parse(migrationStatus).isCompleted ? 'å·²å®Œæˆ' : 'è¿›è¡Œä¸­' : 'æœªå¼€å§‹'}\n\n`;

                // æ£€æŸ¥ IndexedDB
                const db = await openIndexedDB();
                const prompts = await getAllFromStore(db, 'prompts');
                const categories = await getAllFromStore(db, 'categories');
                const settings = await getAllFromStore(db, 'settings');

                output += `ğŸ—„ï¸  IndexedDB:\n`;
                output += `  æç¤ºè¯æ•°æ®: ${prompts.length} æ¡\n`;
                output += `  åˆ†ç±»æ•°æ®: ${categories.length} æ¡\n`;
                output += `  è®¾ç½®æ•°æ®: ${settings.length} æ¡\n\n`;

                // è¯Šæ–­ç»“æœ
                output += `ğŸ¯ è¯Šæ–­ç»“æœ:\n`;
                if (localData && JSON.parse(localData).length > 0 && prompts.length === 0) {
                    output += `  âŒ é—®é¢˜å‘ç°: LocalStorage æœ‰æ•°æ®ä½† IndexedDB ä¸ºç©º\n`;
                    output += `  ğŸ’¡ å»ºè®®: ç‚¹å‡»"æ‰§è¡Œå®Œæ•´è¿ç§»"æŒ‰é’®\n`;
                } else if (prompts.length > 0) {
                    output += `  âœ… è¿ç§»æˆåŠŸ: æ•°æ®å·²æ­£ç¡®è¿ç§»åˆ° IndexedDB\n`;
                } else {
                    output += `  â„¹ï¸  æ— æ•°æ®: æ²¡æœ‰æ‰¾åˆ°éœ€è¦è¿ç§»çš„æ•°æ®\n`;
                }

                db.close();
                result.innerHTML = output;

            } catch (error) {
                result.innerHTML = `âŒ è¯Šæ–­å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡ŒåŸºæœ¬æ£€æŸ¥
        window.onload = function() {
            checkStorageStatus();
            checkMigrationStatus();
        };
    </script>
</body>
</html>
